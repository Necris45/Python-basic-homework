# 3. Осуществить программу работы с органическими клетками, состоящими из ячеек. Необходимо создать класс «Клетка».
# В его конструкторе инициализировать параметр, соответствующий количеству ячеек клетки (целое число). В классе
# должны быть реализованы методы перегрузки арифметических операторов: сложение (__add__()), вычитание (__sub__()),
# умножение (__mul__()), деление (__floordiv____truediv__()). Эти методы должны применяться только к клеткам и
# выполнять увеличение, уменьшение, умножение и округление до целого числа деления клеток, соответственно.
# Сложение. Объединение двух клеток. При этом число ячеек общей клетки должно равняться сумме ячеек исходных двух
# клеток.
# Вычитание. Участвуют две клетки. Операцию необходимо выполнять, только если разность количества ячеек двух клеток
# больше нуля, иначе выводить соответствующее сообщение.
# Умножение. Создаётся общая клетка из двух. Число ячеек общей клетки — произведение количества ячеек этих двух клеток.
# Деление. Создаётся общая клетка из двух. Число ячеек общей клетки определяется как целочисленное деление количества
# ячеек этих двух клеток.
# В классе необходимо реализовать метод make_order(), принимающий экземпляр класса и количество ячеек в ряду.
# Этот метод позволяет организовать ячейки по рядам.
# Метод должен возвращать строку вида *****\n*****\n*****..., где количество ячеек между \n равно переданному
# аргументу. Если ячеек на формирование ряда не хватает, то в последний ряд записываются все оставшиеся.
# Например, количество ячеек клетки равняется 12, а количество ячеек в ряду — 5. В этом случае метод make_order()
# вернёт строку: *****\n*****\n**.
# Или, количество ячеек клетки — 15, а количество ячеек в ряду равняется 5. Тогда метод make_order() вернёт
# строку: *****\n*****\n*****.
# Подсказка: подробный список операторов для перегрузки доступен по ссылке.

class Cell:

    def __init__(self, cells):
        self.cells = cells

    def __add__(self, other):
        return Cell(self.cells + other.cells)

    def __sub__(self, other):
        if (self.cells - other.cells) > 0:
            return Cell(self.cells - other.cells)
        else:
            print("Вычитаемое слишком большое")

    def __mul__(self, other):
        return Cell(self.cells * other.cells)

    def __floordiv__(self, other):
        return Cell(self.cells // other.cells)

    def __truediv__(self, other):
        return Cell(self.cells // other.cells)

    def make_order(self, n):
        cells_string = "*" * self.cells
        result_string = ''
        for i in range(0, len(cells_string), n):
            result_string += cells_string[i:i + n]
            result_string += "\n"
        return result_string.rstrip()


cell1 = Cell(3)
cell2 = Cell(2)
cell3 = cell1 + cell2
print(cell3.cells)
cell4 = cell3 - cell1
print(cell4.cells)
cell5 = cell1 - cell3
cell5 = cell1 * cell2
print(cell5.cells)
cell6 = cell3 / cell1
print(cell6.cells)
cell7 = cell3 // cell2
print(cell7.cells)
cell8 = Cell(17)
print(cell8.make_order(5))
